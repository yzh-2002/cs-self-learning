## TCP
> TCP(Transfer Control Protocol)

前面说过，TCP在IP协议的基础上，实现了建立连接，拥塞控制和流量控制的能力，不是很全面，最关键的在于其在IP尽力而为（数据包可能丢失，乱序）的基础上保证了数据包会`完整的，顺序的`（可靠）到达应用层。

### TCP报文

```P4
header tcp_t {
    bit<16>  src_port;
    bit<16>  dst_port;
    bit<32>  seq_no; //序号
    bit<32>  ack_no; //确认号
    bit<4>   data_offset; //指示TCP报文首部长度
    bit<3>   res; //保留
    bit<3>   ecn; //保留
    bit<6>   ctrl; //控制位，用于指示TCP报文的控制信息，如SYN、ACK、FIN等。
    bit<16>  window; //接收窗口--愿意接收的字节数量
    bit<16>  checksum;
    bit<16>  urgent_ptr; //指示TCP报文中的紧急数据的位置。
    
    bit<32>  options; //可选字段，用于扩展TCP报文的功能，如选择性确认、时间戳等。
    //应用层报文
}
```

#### 序号和确认号？

TCP会将传输的报文看作一整个连续的字节流，并对其进行分段传输，`序号`就是值当前报文段首字节在整个字节流中的编号。`确认号`则是接收方期望接收的下一个字节的序号（TCP中采用`累积确认`）。

对于乱序的数据包，TCP协议（相关RFC）并没有规定如何处理，具体实现可能和操作系统相关，目前有`有序缓冲区`和`滑动窗口`等多种实现方式（感兴趣自行搜索）。

#### 定时器时间设置？

需要明确的标准是，定时器的超时时间应该略大于RTT,否则过小会导致不必要的重传，过大则无法及时重传，比较消极。

问题是RTT的时间是波动的，如何估算呢？

`SampleRTT`：测量从报文段发出到收到确认的时间。（如果有重传，则忽略此次时间）

预估的RTT时间：
`EstimatedRTT`：$EstimatedRTT= (1-\alpha)*EstimatedRTT + \alpha* SampleRTT  $

安全边界时间：（估算RTT与上次RTT相差越大，安全边界时间越大）
`DevRTT`:$ DevRTT=(1-\beta)*DevRTT + \beta* |EstimatedRTT-SampleRTT| $

超时时间：（仅供参考，具体问题具体分析）
`TimeoutInterval`:$TimeoutInterval = EstimatedRTT + 4*DevRTT$


### 可靠数据传输
> TCP在IP的基础上实现了可靠数据传输，原理之前已经讲过，不再赘述

TCP接收方采用`累积确认`的策略，发送方只需启动`已发送未确认`的`最小序号`的数据包的`定时器`即可。虽然每次接收方受到数据包，都应该给发送方返回一个ACK,但实际上有些可优化的点：

接收方优化点：

1. 所期望序号的报文段按序到达。所有在期望序号之前的数据都已经被确认：
    1. `延迟的ACK`。对另一个按序报文段的到达`最多等待500ms`。如果下一个报文段在这个时间间隔内没有到达，则发送一个 ACK。
    2. 优化点：可以`减少ACK数据包数量`，减少链路压力。
2. 有期望序号的报文段到达。另（前）一个按序报文段等待发送 ACK：
    1. `立即`发送单个累积 ACK，以确认两个按序报文段。（防止前一个报文超时）
3. 比期望序号大的报文段乱序到达。检测出数据流中的间隔：
    1. 立即发送重复的ACK，指明下一个期待字节的序号
4. 能部分或完全填充接收数据间隔的报文段到达：
    1. 若该报文段起始于间隔（gap）的低端，则立即发送（累积）ACK。
    2. 否则立即发送重复ACK...

发送方优化点：

1. 接收到三个重复ACK
    1. 立即重传最小未确认序号的数据包
    2. 三个重复ACK说明最小未确认序号的数据包定时器时间设置过长（且该数据包大概率已经丢失），此时不再等待立刻重传。

### 流量控制
> 接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出。（虽然TCP接收方采用累积确认，但并不代表其像GBN一样只能接收一个数据包）

值得注意的是，这里的缓存区和滑动窗口的大小不同，应用层会从SOCKET缓冲区中获取可靠数据，而TCP传输过程中，发送方发送的数据又会到接收方（接收方可以按照`滑动窗口`的设计（或其他，TCP未定义）来处理数据包，并将其`排序后`填充给`缓冲区`供应用层消费。）

在下面讲到的TCP建立连接时，接收方和发送方会初始化一个窗口大小，在报文的`WINDOW`字段里，以后每次接收方返回ACK报文时，都会写到自己可接收的窗口大小。当窗口大小为0时，发送方可以每隔一段时间发送大小为1字节的数据包来检测接收方的窗口变化。

### TCP连接建立
> 在正式交换数据之前，发送双方握手建立通信关系。

建立连接，三次握手：

1. 发送方发送SYN报文：SYN bit置为1,Seq序号为一个随机初始值`x`
2. 接收方收到，返回SYNACK报文：SYN bit置为1,Seq序号是一个随机初始值`y`，ACK bit置为1,ACK序号为`x+1`
3. 发送方受到SYNACK报文，发送SYNACK的ACK,ACK bit置为1,ACK序号为`y+1`

常见问题：

1. 为什么不能二次握手，而要三次握手？[参考文章](https://www.zhihu.com/question/24853633/answer/573627478)
2. 为什么Seq序号要选一个随机值，而不是置为0？[参考文章](https://www.zhihu.com/question/53658729)

个人总结：其实两个问题都在说一件事，在不可靠的信道上，通信双方想要实现可靠通信，必须借助于基于序号的一整套可靠传输方法，如果无法在传输数据之前在序号设置上达成共识，就一定会出现各种各样的问题。

比如谢希仁提到的`为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误`，如果有一个全局时钟来告知当前新建立的TCP连接序号应该为多少，就可以轻易识别这个已经是小的连接请求。

断开连接，四次挥手：

1. `发送方`数据发送完毕，发送FIN报文：FIN bit置为1
2. `接收方`收到FIN报文，返回ACK：此时`接收方`还可以发送报文（可能还有数据没传输完）
3. `发送方`收到之后等到接收方的FIN报文
4. `接收方`数据发送完毕，发送FIN报文
5. `发送方`受到FIN报文，返回ACK，并等待2MSL（Maximum Segment Lifetime）后关闭连接。

原因：如果自己的ACK报文丢失，那么接收方由于没有受到确认，可能会再发一遍FIN报文，而2MSL之后还没受到，说明接收方一定受到了ACK报文。

### 拥塞控制

如何检测到拥塞？

1. 数据包超时：大概率比是因为拥塞导致，小概率是因为数据包BIT出错导致（认定为`拥塞`）
2. 三次重复ACK：低序数据包大概率丢失，但是还能收到高序数据包，说明不严重（认定为`轻微拥塞`）

如何控制速率？

维护一个拥塞窗口的值`CONGWIN`，使得已发送但未确认的数据量小于该值（同时也要满足`流量控制`窗口大小的要求）。`CongWin`是动态的，根据上面检测拥塞的条件可得：

1. 数据包超时：`CongWin`降为`1MSS`，进入`SS阶段`直到增加至`CongWin/2`（此时的CongWin为上次超时的拥塞窗口大小，也即`Threshold`）后再进入`CA阶段`
2. 三次重复ACK：`Threshold`为`CongWin/2`，`CongWin`降为`Threshold+3`，`CA阶段`

`SS阶段`：一个RTT倍数增加，一个ACK便增加1,`CA阶段`：线性增加，一个RTT未发生丢失时间就加1