## pipe

管道分为匿名管道和命名管道，匿名管道较为常见，例如命令行中`|`就是匿名管道，平时进程间通信时通过`pipe`创建的也是匿名管道。

这里有一个细节：

在`fork`创建子进程之前，必须先通过`pipe`创建管道，这样子进程复制父进程的地址空间时就会获得同一个管道的文件描述符，继而实现父子进程的通信。不仅仅是管道，任何子进程从父进程里拷贝的fd，子进程均可操作对应文件。

```
文件描述符本质上对应了内核中的一个表单数据。内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的key是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的点是，每个进程都有自己独立的文件描述符空间，所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。
```

匿名管道由于基于子进程复制父进程的地址空间从而实现两者通信，因此对于其他进程是不可见的。

对于命名管道，我们可以通过`mkfifo`创建，对任何进程可见，（我）目前使用较少，不再过多阐述。

### pipe/io

下面看下管道读写的特点：

在管道中没有数据的情况下，对管道的读操作会`阻塞`，直到管道内有数据为止。当一次写的数据量不超过管道容量的时候，对管道的写操作`一般不会阻塞`，直接将要写的数据写入管道缓冲区即可。

如果涉及到进程的半双工通信需要考虑上述条件，但实际上半双工的情况比较复杂，更多推荐的还是单工通信。

从管道读取内容时，暂无可读会阻塞，读取时只需要关系每次读取内容的字节数，读取之后会改变fd的offset。如果写入端被关闭，`read`函数会直接返回0