## OS Interface
> 参考XV6文档第0章的内容

操作系统的作用：
1. Abstraction：抽象硬件，屏蔽底层细节，便于上层应用开发 && 提高移植性
2. Multiplexing：允许多个应用程序共用硬件资源
3. Isolation：与Multilpexing紧密相关，多个应用程序共用硬件资源，就需要解决彼此之间的隔离性问题，防止互相影响
4. Sharing：与Isolation紧密相关，我们希望共同运行的应用不会彼此影响，但同时也要求其之间可以进行数据交互。
5. Performance：操作系统应该尽可能充分发挥底层硬件的性能

操作系统以接口的形式为上层应用提供服务，用户程序获取该服务需要进行**系统调用**

### 进程和内存

进程由两部分组成：一部分在用户空间（指令，数据，栈），一部分在内核空间（进程状态，PCB），内核将一个进程与一个`pid`对应。相关系统调用：

1. `fork`：创建一个子进程，子进程的内存中的值与父进程一致（值一致，内存地址不一致），该函数在父进程中返回子进程pid,子进程中返回0
2. `exit`：结束当前调用进程，并回收内存和打开的文件
3. `wait`：父进程等待其中任一子进程结束，阻塞当前父进程，返回结束子进程的pid
4. `exec`：从某个文件（可执行文件）读取内存镜像并替换当前调用进程的用户空间，调用成功不返回，而是执行从指定文件中加载的指令

shell程序工作原理：
1. 父进程循环读取用户输入的命令（getcmd）
2. 创建子进程（fork）
    1. 子进程通过exec执行用户输入的命令
    2. 父进程调用wait等待子进程执行用户输入的命令


### I/O & 文件描述符

文件描述符是一个整数，代表一个进程可以读写的被内核管理的对象。

每一个进程都有一张表，表的索引即为文件描述符，值中包含偏移量等信息。相关系统调用：

1. `read`
2. `write`
3. `open`
4. `close`
5. `dup`
6. `pipe`

`fork`创建的子进程除了复制父进程的内存外，还复制父进程的文件描述符，**同时`exec`虽然替换了内存，但是文件描述符会被保留**，故可以基于此实现IO重定向：

```c++
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
    close(0);
    // 一个新分配的文件描述符永远都是当前进程的最小的未被使用的文件描述符，故该文件对应fd为0
    open("input.txt", O_RDONLY); 
    exec("cat", argv);
}
```

### 管道
> 见[PIPE](./pipe.md)

### 文件系统
> 见[FS](./fs.md)


